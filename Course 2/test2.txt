                    # else:
                    #     temp = i
                    #     i = j
                    #     j = temp
                    #     if v1[i] == 1 and v1[j] == 1:
                    #         n = v1[0:i]
                    #         n.extend([0])
                    #         n.extend(v1[i+1:j])
                    #         n.extend([0])
                    #         n.extend(v1[j+1:len(v1)])
                    #     elif v1[i] == 0 and v1[j] == 1:
                    #         n = v1[0:i]
                    #         n.extend([1])
                    #         n.extend(v1[i+1:j])
                    #         n.extend([0])
                    #         n.extend(v1[j+1:len(v1)])
                    #     elif v1[i] == 1 and v1[j] == 0:
                    #         n = v1[0:i]
                    #         n.extend([0])
                    #         n.extend(v1[i+1:j])
                    #         n.extend([1])
                    #         n.extend(v1[j+1:len(v1)])
                    #     else:
                    #         n = v1[0:i]
                    #         n.extend([1])
                    #         n.extend(v1[i+1:j])
                    #         n.extend([1])
                    #         n.extend(v1[j+1:len(v1)])
                    #     temp = i
                    #     i = j
                    #     j = temp
                    # if len(n) == len(v1):
                    #     arr.append(n)

#
# def sum_of(x):
#     s = 0
#     for i in range(0, 24):
#         if x[i] == 1:
#             s = s + 1
#     return s
#
#
# points.sort(key=sum_of)
#
# partition_index_by_sum = {}
#
# i = 0
# for s in range(3, 24):
#     start = i
#     while sum_of(points[i]) < s:
#         i = i+1
#         if i == num_nodes:
#             break
#     end = i
#     partition_index_by_sum[s-1] = [start, end]
#
#
# print(partition_index_by_sum)
#
#
# def get_possible_sums(s):
#     ps = [t for t in range(s-2,s+3) if (1 < t < 23)]
#     return ps
#
#
# def dist(a, b):
#     d = 0
#     for i in range(0, 24):
#         d = d + ((a[i]+b[i]) % 2)
#     return d
#
#
# for s in partition_index_by_sum.keys():
#     sums_to_check = get_possible_sums(s)
#     min_sum = sums_to_check[0]
#     max_sum = sums_to_check[len(sums_to_check)-1]
#     valid_range = [partition_index_by_sum[min_sum][0], partition_index_by_sum[max_sum][1]]
#     for i in range(valid_range[0], valid_range[1]):
#         for j in range(i+1, valid_range[1]):
#             e = [i, j]
#             d = dist(points[i], points[j])
#             e.append(d)
#             g.append(e)
#     print(s)
#
# print(g)

#
# for e in edges:
#     if No_clusters > 4:
#         v1 = e[0]
#         v2 = e[1]
#         v1_leader = leader(v1)
#         v2_leader = leader(v2)
#         if size(v1_leader) > size(v2_leader):
#             merge(v1_leader, v2_leader)
#             No_clusters = No_clusters - 1
#         elif size(v1_leader) < size(v2_leader):
#             merge(v2_leader, v1_leader)
#             No_clusters = No_clusters - 1
#         elif size(v1_leader) == size(v2_leader):
#             if v1_leader == v2_leader:
#                 pass
#             else:
#                 merge(v1_leader, v2_leader)
#                 No_clusters = No_clusters - 1